/**********************************************************************************************/
/*                                                                                            */
/*                                   Драйвер дисплея.                                         */
/*                                                                                            */
/**********************************************************************************************/
#include  "display.h"
#include  "Font_6x8.c"
#include  "Font_7x10_thin.c"
#include  "Font_12x16.c"

/*--------------------------------------------------------------------------------------------*/
/* Процедура инициализации дисплея.                                                           */
/* Принимает:   ничего не принимает.                                                          */
/* Возвращает:  ничего не возвращает.                                                         */
/*--------------------------------------------------------------------------------------------*/
void Display_Init(void)
{
  // Переводим в исходное состояние линии управления ЖКИ:
  // все выходы в нулевом состоянии, только CS1 и CS2 = "1".

  DDRB |= (1 << LCD_E);
  PORTB &= ~(1 << LCD_E) ;
  DDRC |=  (1 << LCD_RW) | (1 << LCD_A0) | (1 << LCD_CS2) | (1 << LCD_CS1) | (1 << LCD_RES) ;
  PORTC &= ~((1 << LCD_RW) | (1 << LCD_A0) | (1 << LCD_CS2) | (1 << LCD_CS1) | (1 << LCD_RES) );
  //PORTC |= (1 << LCD_CS1) | (1 << LCD_CS2);
  // Выполняем аппаратный сброс модуля. Паузы формируем программно, так как
  // прерывания еще могут быть не разрешены.
  Clr_Line_in_Port(LCD_RES_PIN);
  __delay_cycles(100);
  Set_Line_in_Port(LCD_RES_PIN);
  __delay_cycles(100);
  // Очищаем и включаем дисплей.
 LCD_Clear();
  Write_Cmd_Display_ON();

  // Включаем подсветку, если это разрешено.
  return;
}

/*--------------------------------------------------------------------------------------------*/
/* Процедура чтения состояния контроллера ЖКИ.                                                */
/* Принимает:   контроллер (0, 1).                                                            */
/* Возвращает:  считанное состояние.                                                          */
/*--------------------------------------------------------------------------------------------*/
/*OUT BYTE Read_Status_from_LCD(IN IDX c)
{
  // Переведем шину данных на ввод и выставим все управляющие сигналы.
  LCD_Data_Bus_To_Input();
  PORTC |= (1 << LCD_RW); PORTC &= ~(1 << LCD_A0 );PORTB &= ~(1 << LCD_E);
  (c == 0) ? (Set_Line_in_Port(LCD_CS1_PIN)) : (Set_Line_in_Port(LCD_CS2_PIN));
  // Сформируем строб и считаем с шины данных состояние контроллера.
  Set_Line_in_Port(LCD_E_PIN);
  __delay_cycles(100);
  register BYTE state = Get_Data_from_LCD_Data_Bus();
  Clr_Line_in_Port(LCD_E_PIN);
  // Снимем выборки с ЖКИ.
  PORTC &= ~((1 << LCD_CS1) | (1 << LCD_CS2));
  return state;
}
*/
/*--------------------------------------------------------------------------------------------*/
/* Процедура ожидания готовности контроллера ЖКИ.                                             */
/* Принимает:   контроллер (0, 1).                                                            */
/* Возвращает:  true, если контроллер готов, false иначе.                                     */
/*--------------------------------------------------------------------------------------------*/
OUT bool Wait_LCD_Ready(IN IDX c)
{
  register BYTE i = 0;
  // Переведем шину данных на ввод и выставим все управляющие сигналы.
  LCD_Data_Bus_To_Input();
  PORTC |= (1 << LCD_RW); PORTC &= ~(1 << LCD_A0 );PORTB &= ~(1 << LCD_E);
  (c == 0) ? (Set_Line_in_Port(LCD_CS1_PIN)) : (Set_Line_in_Port(LCD_CS2_PIN));
  // Сформируем строб и считаем с шины данных состояние контроллера.
  for(i = 0; i < 10; i++)
     {
      // __delay_cycles(5);
       Set_Line_in_Port(LCD_E_PIN);
      // __delay_cycles(100);
       register BYTE state = Get_Data_from_LCD_Data_Bus();
       Clr_Line_in_Port(LCD_E_PIN);
       if((state & (1 << 7)) == 0) break;
     }
  // Снимем выборки с ЖКИ.
  PORTC &= ~((1 << LCD_CS1) | (1 << LCD_CS2));
  return (i < 10) ? (true) : (false);
}
/*--------------------------------------------------------------------------------------------*/
/* Процедура ожидания готовности контроллера ЖКИ.                                             */
/* Принимает:   ничего.                                                            */
/* Возвращает:  true, если контроллер готов, false иначе.                                     */
/*--------------------------------------------------------------------------------------------*/
OUT bool Wait_LCD_Ready(void)
{
  register BYTE i = 0;
  // Переведем шину данных на ввод и выставим все управляющие сигналы.
  LCD_Data_Bus_To_Input();
  PORTC |= (1 << LCD_RW); PORTC &= ~(1 << LCD_A0 );PORTB &= ~(1 << LCD_E);
  // Сформируем строб и считаем с шины данных состояние контроллера.
  for(i = 0; i < 10; i++)
     {
    //   __delay_cycles(100);
       Set_Line_in_Port(LCD_E_PIN);
      // __delay_cycles(100);
       register BYTE state = Get_Data_from_LCD_Data_Bus();
       Clr_Line_in_Port(LCD_E_PIN);
       if((state & (1 << 7)) == 0) break;
     }
  return (i < 10) ? (true) : (false);
}



/*--------------------------------------------------------------------------------------------*/
/* Процедура записи команды в контроллеры ЖКИ.                                                */
/* Принимает:   контроллер (0, 1), код записываемой команды.                                  */
/* Возвращает:  ничего не возвращает.                                                         */
/*--------------------------------------------------------------------------------------------*/
void Write_Cmd_to_LCD(IN BYTE cmd)
{
  // Дождемся готовности контроллера ЖКИ.
  //Wait_LCD_Ready();
  //__delay_cycles(100);
  // Переведем шину данных на вывод и выставим все управляющие сигналы.
  LCD_Data_Bus_to_Output();
  PORTC &= ~((1 << LCD_A0) | (1 << LCD_RW)); PORTB &= ~(1 << LCD_E);
 // (c == 0) ? (Set_Line_in_Port(LCD_CS1_PIN)) : (Set_Line_in_Port(LCD_CS2_PIN));
  // Выставим на шину данных код команды и сопроводим его стробом.
 // __delay_cycles(100);
  Put_Data_to_LCD_Data_Bus(cmd);
   //__delay_cycles(100);
  Set_Line_in_Port(LCD_E_PIN);
  //__delay_cycles(100);
  Clr_Line_in_Port(LCD_E_PIN);
  __delay_cycles(100);
  // Снимем выборки с ЖКИ.
 // PORTC &= ~((1 << LCD_CS1) | (1 << LCD_CS2));
  return;
}

/*--------------------------------------------------------------------------------------------*/
/* Процедура записи 1 байта данных в контроллер ЖКИ.                                          */
/* Принимает:   контроллер (0, 1), записываемый байт данных.                                  */
/* Возвращает:  ничего не возвращает.                                                         */
/*--------------------------------------------------------------------------------------------*/
/*void Write_Data_to_LCD(IN IDX c, IN BYTE data)
{
  // Дождемся готовности контроллера ЖКИ.
  Wait_LCD_Ready(c);
  // Переведем шину данных на вывод и выставим все управляющие сигналы.
  LCD_Data_Bus_to_Output();
  PORTC |= (1 << LCD_A0); PORTC &= ~(1 << LCD_RW);PORTB &= ~(1 << LCD_E);
  (c == 0) ? (Set_Line_in_Port(LCD_CS1_PIN)) : (Set_Line_in_Port(LCD_CS2_PIN));
  // Выставим на шину данных байт данных и сопроводим его стробом.
 // __delay_cycles(100);
  Put_Data_to_LCD_Data_Bus(data);
  //__delay_cycles(100);
  Set_Line_in_Port(LCD_E_PIN);
 // __delay_cycles(100); 
  Clr_Line_in_Port(LCD_E_PIN);
 // __delay_cycles(100);
  // Снимем выборку с ЖКИ.
  PORTC &= ~((1 << LCD_CS1) | (1 << LCD_CS2));
  return;
}

*/



/*--------------------------------------------------------------------------------------------*/
/* Процедура записи 1 байта данных в текущий контроллер ЖКИ.                                          */
/* Принимает:   записываемый байт данных.                                  */
/* Возвращает:  ничего не возвращает.                                                         */
/*--------------------------------------------------------------------------------------------*/
void Write_Data_to_LCD( IN BYTE data)
{
  // Дождемся готовности контроллера ЖКИ.
  //Wait_LCD_Ready();
  // Переведем шину данных на вывод и выставим все управляющие сигналы.
  LCD_Data_Bus_to_Output();
  PORTC |= (1 << LCD_A0); PORTC &= ~(1 << LCD_RW);PORTB &= ~(1 << LCD_E);
  // Выставим на шину данных байт данных и сопроводим его стробом.
  //__delay_cycles(100);
  Put_Data_to_LCD_Data_Bus(data);
  //__delay_cycles(100);
  Set_Line_in_Port(LCD_E_PIN);
  //__delay_cycles(100); 
  Clr_Line_in_Port(LCD_E_PIN);
  //__delay_cycles(100);
  return;
}



/*--------------------------------------------------------------------------------------------*/
/* Процедура записи n копий байта данных в контроллер ЖКИ.                                    */
/* Принимает:   выводимый байт, число его повторений.                      */
/* Возвращает:  ничего не возвращает.                                                         */
/*--------------------------------------------------------------------------------------------*/
void Write_Data_to_LCD( IN BYTE data, IN BYTE n)
{
  // Дождемся готовности контроллера ЖКИ.
  //Wait_LCD_Ready();
  // Переведем шину данных на вывод и выставим все управляющие сигналы.
  LCD_Data_Bus_to_Output();
  PORTC |= (1 << LCD_A0); PORTC &= ~(1 << LCD_RW);PORTB &= ~(1 << LCD_E);
  // В цикле выcтавляем на шину данных байт данных и сопровождаем его стробом.
  for(register BYTE i = 0; i < n; i++)
     {
       //__delay_cycles(100);
       Put_Data_to_LCD_Data_Bus(data);
      // __delay_cycles(100);
       Set_Line_in_Port(LCD_E_PIN);
      // __delay_cycles(100);
       Clr_Line_in_Port(LCD_E_PIN);
      // __delay_cycles(100);
     }

  return;
}


/*--------------------------------------------------------------------------------------------*/
/* Процедура очистки ЖКИ.                                                                     */
/* Принимает:   ничего не принимает.                                                          */
/* Возвращает:  ничего не возвращает.                                                         */
/*--------------------------------------------------------------------------------------------*/
void LCD_Clear(void)
{
  for(register IDX page = 0; page < 8; page++)
     {
       
       Set_all_crystal();//Set_crystal(0);
       Write_Cmd_Page_Addr_Set(page);// Установим страницу.
       Write_Cmd_Column_Addr_Set(0);
       Write_Data_to_LCD((BYTE)0xFF, 64);
       
      // Set_crystal(1);
      // Write_Cmd_Page_Addr_Set(page);
      // Write_Cmd_Column_Addr_Set(0);
       //Write_Data_to_LCD((BYTE)0xFF, 64);       // Очистим все столбцы страницы.
     }
  return;
}

/*--------------------------------------------------------------------------------------------*/
/* Процедура чтения 1 байта данных из контроллера ЖКИ.                                        */
/* Принимает:   контроллер (0, 1).                                                            */
/* Возвращает:  считанный байт.                                                               */
/*--------------------------------------------------------------------------------------------*/
OUT BYTE Read_Data_from_LCD()
{
  // Дождемся готовности контроллера ЖКИ.
  //Wait_LCD_Ready();
  // Переведем шину данных на ввод и выставим все управляющие сигналы.
  LCD_Data_Bus_To_Input();
  PORTC |= (1 << LCD_A0) | (1 << LCD_RW); PORTB &= ~(1 << LCD_E);
 //(c == 0) ? (Set_Line_in_Port(LCD_CS1_PIN)) : (Set_Line_in_Port(LCD_CS2_PIN));
  // Первое чтение - dummy.

  Set_Line_in_Port(LCD_E_PIN);

  Clr_Line_in_Port(LCD_E_PIN);

  // Сформируем строб и считаем с шины данных байт.
  Set_Line_in_Port(LCD_E_PIN);

  register BYTE data = Get_Data_from_LCD_Data_Bus();

  Clr_Line_in_Port(LCD_E_PIN);

  // Снимем выборку с ЖКИ.
  //PORTC &= ~((1 << LCD_CS1) | (1 << LCD_CS2));
  return data;
}



// функция применяет маску к байту на экране
inline void Mask_on_scr(BYTE x,BYTE mask)
{
  Write_Cmd_Column_Addr_Set(x);
  Set_crystal(0);
  BYTE data=Read_Data_from_LCD();
  Write_Cmd_Column_Addr_Set(x);
  Write_Data_to_LCD(data & mask);
  Set_crystal(1);
  data=Read_Data_from_LCD();
  Write_Cmd_Column_Addr_Set(x);
  Write_Data_to_LCD(data & mask);

}


void Clr_Lines(IN BYTE y, IN BYTE h)
{

  //if (y>=64) y-=64;
  
  BYTE start_page=(y/8); // страница начала
  BYTE before=8-(y%8); // пикселей до начала страницы
  BYTE after=((y+h)%8); // пикселей от конца страницы
  BYTE page=(h-before)/8 ;  //сколько целых страниц в регине стирания
  if (before==8)page++;
  
  BYTE i,mask;
  

// ----------------стирание до начала целой страницы  -------------------

  if ((before!=0)& (before!=8))// если требуется стирание
  {
      if (start_page>=8)start_page-=8; // зашита от переполнения счетчика страниц (не больше 7)
      Set_all_crystal();
      Write_Cmd_Page_Addr_Set(start_page);   // устанавливаем страницу в оба кристала
      start_page++;

      mask=(0xFF>>before);// маска в верхней части ситирания
      if (before>h) // если толщина стирания меньше страницы
      {
          after=0;  // нижняя половина стирания не применяется
          mask=mask | (0xFF<<(8-before+h));
      }
      for( i= 0; i < 64; i++)Mask_on_scr(i,mask); // применияем маску
  }  
//---------------------------------------------------------------------------------
 
//----------------------- быстрое постраничное стирание --------------------------
  for(i = 0; i <page; i++)  // постарнично
  {

    Set_all_crystal(); // в оба кристала
    if (start_page>=8)start_page-=8;// зашита от переполнения счетчика страниц (не больше 7)
    Write_Cmd_Page_Addr_Set(start_page);
    Write_Cmd_Column_Addr_Set(0)
    Write_Data_to_LCD(0x00,64);
    start_page++;
  }
 
//---------------------------------------------------------------------------  
// ----------------стирание от конца целой страницы  -------------------
  BYTE data;
  if (after!=0)// если требуется стирание
  {
      if (start_page>=8)start_page-=8; // зашита от переполнения счетчика страниц (не больше 7)
      Set_all_crystal();
      Write_Cmd_Page_Addr_Set(start_page);   // устанавливаем страницу в оба кристала
      mask=(0xFF<<after);// маска в нижней части ситирания
      for( i= 0; i < 64; i++) Mask_on_scr(i,mask); // применияем маску
  }  
//---------------------------------------------------------------------------------  

  
}





















/*--------------------------------------------------------------------------------------------*/
/* Функция вывода на экран одного байта изображения                                    */
/* Принимает:   координаты байта.
                байт
                флаги вывода                                                          */
/* Возвращает:  сничего                                                               */
/*--------------------------------------------------------------------------------------------*/

int Draw_Byte( IN BYTE x, IN BYTE y, IN BYTE data,IN BYTE flags)
{
  BYTE crystal=0;
  BYTE page;
  BYTE shift;
  
  BYTE mask;
  BYTE shift_data;
  BYTE old_data;
  BYTE new_data;
  
  if (y >= MAX_HEIGHT) y-=MAX_HEIGHT;
  
      if(x >= MAX_WIDTH) return 1; // проверяем диапазон
      
      if(x>=64) {crystal=1; x=x-64;} //номер кристала
    page=y/8; // номер страницы
    shift=y%8; // смещение байта по вертикали
    
    Set_crystal(crystal);
    
     Write_Cmd_Page_Addr_Set( page);
     Write_Cmd_Column_Addr_Set(x);
     
     //Write_Cmd_to_LCD( 0xb8 + (page))
     //Write_Cmd_to_LCD( 0x40 + (x));
     
 //----------- быстрая запись, при y пратной 8 -----------------------------    
     if ((flags==DRAW_DIRECT)& (shift==0))
     {
       //Write_Data_to_LCD(crystal,data); // прямая запись без смещения
        Write_Data_to_LCD(data); // прямая запись без смещения
       return 0;
     }
    
       
       
// ---------------------------------------------------------------------     
//------------- записываем первую часть байта --------------     
     shift_data=(data<<shift);             //берем верхнюю половину байта
     old_data=Read_Data_from_LCD(); // считываем текущее

     
      if (flags==DRAW_DIRECT) // при выводе с перекрытием стираем ненужный кусок старого изображения
      { 
        mask=(0xFF>>(8-shift)); 
        old_data &= mask;                 // обрезаем старое изображение
      }
      
     Write_Cmd_Column_Addr_Set(x);   //возвращаем указатель в исходное положение      
           
      if (flags==DRAW_XOR) // вывод с XOR
      {
        new_data=XOR(shift_data, old_data); // наклыдываем получившиеся байты по XOR
      }
      else new_data=(shift_data | old_data); // наклыдываем получившиеся байты DRAW_OVER и DRAW_DIRECT

     Write_Data_to_LCD (new_data);
 //----------------------------------------------------------------------------
    // return 0;
     
      //if((shift != 0) & (y >= MAX_HEIGHT+1)) return 1; // не допускаем размещения второй части байта на 65 страннице
    page++;
     if (page==8)page=0;
      
     Write_Cmd_Page_Addr_Set(page);
     Write_Cmd_Column_Addr_Set(x);
// ------------------- и вторую часть байта -----------------------     
     shift_data=(data >> (8-shift));  //берем нижнюю половину байта
     old_data=Read_Data_from_LCD(); // считываем текущее
     
     
     
     if (flags==DRAW_DIRECT) // при выводе с перекрытием стираем ненужный кусок старого изображения
      { 
        mask=(0xFF<<(shift)); 
        old_data &= mask;                 // обрезаем старое изображение
      }
      
     Write_Cmd_Column_Addr_Set(x);   //возвращаем указатель в исходное положение      
           
      if (flags==DRAW_XOR) // вывод с XOR
      {
        new_data=XOR(shift_data, old_data); // наклыдываем получившиеся байты по XOR
      }
      else new_data=(shift_data | old_data); // наклыдываем получившиеся байты DRAW_OVER и DRAW_DIRECT

     Write_Data_to_LCD (new_data);
 //----------------------------------------------------------------------------    
  return 0;
}







/*--------------------------------------------------------------------------------------------*/
/* Процедура вывода битового образа по заданным координатам.                                  */
/* Принимает:   координаты вывода изображения (графические),                                  */
/*              ширину и высоту изображения,                                                  */
/*              адрес таблицы с битовым образом во flash,                                     */
/*              байт признаков вывода изображения.                                            */
/* Возвращает:  ничего не возвращает.                                                         */
/*--------------------------------------------------------------------------------------------*/
int Draw_Bitmap(IN BYTE x, IN BYTE y, IN BYTE w, IN BYTE h, IN BYTE __flash *pData, IN BYTE flags)
{
 
 BYTE __flash *p = pData ;
  BYTE data ;
   
  BYTE page=h/8;  //сколько страниц занимает наша bitmap (обычно 1-2-3)
  BYTE shift=h%8;
  if (shift!=0) page++;
  
   for(BYTE i = 0; i < page; i++)
   {
       for(BYTE j = 0; j < w; j++)
      {
        data =*(p++);
         Draw_Byte( x+j, y+(i*8), data,flags);

     }
     }   
        return 0;
}


/*--------------------------------------------------------------------------------------------*/
/* Процедура вывода строки заданным шрифтом по заданным координатам.                          */
/* Принимает:   адрес строки в ОЗУ,                                                           */
/*              координаты вывода символа (графические),                                      */
/*              адрес структуры описания шрифта во flash,                                     */
/*              байт признаков вывода изображения.                                            */
/* Возвращает:  ничего не возвращает.                                                         */
/*--------------------------------------------------------------------------------------------*/
int Draw_Text(IN char *str, IN BYTE X, IN BYTE Y, IN struct FONT __flash *font, IN BYTE flags)
{
  // Последовательно выводим символы строки до признака ее завершения (0x00).
  while(*str != 0)
    {
      // Выводим текущий символ.
      if (Draw_Char(*str, X, Y, font, flags)) return 1;
      str++;
      X += font->Width;
    }
  return 0;
}

/*--------------------------------------------------------------------------------------------*/
/* Процедура вывода строки заданным шрифтом по заданным координатам.                          */
/* Принимает:   адрес строки во flash,                                                        */
/*              координаты вывода символа (графические),                                      */
/*              адрес структуры описания шрифта во flash,                                     */
/*              байт признаков вывода изображения.                                            */
/* Возвращает:  ничего не возвращает.                                                         */
/*--------------------------------------------------------------------------------------------*/
int Draw_Text(IN char __flash *str, IN BYTE X, IN BYTE Y, IN struct FONT __flash *font, IN BYTE flags)
{
  // Последовательно выводим символы строки до признака ее завершения (0x00).
  while(*str != 0)
    {
      // Выводим текущий символ.
      if (Draw_Char(*str, X, Y, font, flags)) return 1;
      str++;
      X += font->Width;
    }
  return 0;
}

/*--------------------------------------------------------------------------------------------*/
/* Добовление новой строки на экран с автоматической прокруткой                                                      */
/* Принимает: адрес строки                                                           */
/*              координаты вывода символа (графические),                                      */
/*              адрес структуры описания шрифта во flash,    
                номер верхней строки на экране                                          */
/* Возвращает:  новые координаты коретки X и Y                                                      */
/*--------------------------------------------------------------------------------------------*/

int Add_Text(IN char *str, IN struct FONT __flash *font)//, OUT BYTE X_new,OUT Y_new)
{
  // Последовательно выводим символы строки до признака ее завершения (0x00).
  BYTE W_border=(MAX_WIDTH-(font->Width));
  BYTE S;
  BYTE x,y;
  
           
      if (Y>=MAX_HEIGHT) Y-=MAX_HEIGHT;
      y=Y;
      if (y>carrent_offset) S=y-carrent_offset;  // вычисляем растояние от carrent_offset до начала символа
        else S=MAX_HEIGHT+y-carrent_offset;
      S+=(font->Height);                          // вычисляем растояние от carrent_offset до конца символа
      if (S>MAX_HEIGHT) Start_Line_increment(S-MAX_HEIGHT); // если символ не умещается на странице - перевод каретки


  while(*str != 0)
    {
      if (X>=W_border)  // перевод каретки если доходим до конца экрана
      {
        X=0;
        Y+=font->Height;
        if (Y>=MAX_HEIGHT) Y-=MAX_HEIGHT;
        y=Y;
        if (y>carrent_offset) S=y-carrent_offset;  // вычисляем растояние от carrent_offset до начала символа
          else S=MAX_HEIGHT+y-carrent_offset;
        S+=(font->Height);                          // вычисляем растояние от carrent_offset до конца символа
        if (S>MAX_HEIGHT) Start_Line_increment(S-MAX_HEIGHT); // если символ не умещается на странице - перевод каретки
      }

      // Выводим текущий символ.
          x=X;
          y=Y;
      Draw_Char(*str, x, y, font, DRAW_DIRECT);
      str++;
      X +=font->Width;

      
    }
  return 0;
}

/*--------------------------------------------------------------------------------------------*/
/* Прокрутка стартовой строки Start_Line                                                      */
/* Принимает:  текущую верхнюю строку
                сколько строк прокручивать                                                       */
/* Возвращает:  ничегj                                                                          */
/*--------------------------------------------------------------------------------------------*/

void Start_Line_increment(IN BYTE offset_step)
{
  Clr_Lines(carrent_offset,offset_step);
  carrent_offset+=offset_step;
   Set_all_crystal();
    if (carrent_offset>=64) carrent_offset-=64;
 
     Write_Cmd_Set_Start_Line(carrent_offset);
   // Clr_Lines(Y,offset_step);
}

//-----------------строчные функции --------------------------------------------
// принивают байт и переводят его в символя десятичные или шеснадцатиричные
//--------------------------------------------------------------------------

char* Convert_dec_to_str( IN BYTE byte)
{
  char* str="000";
  BYTE h=byte/100;
  BYTE d=(byte%100)/10;
  BYTE e=byte%10;
  *(str+0)=h+0x30;
  *(str+1)=d+0x30;
  *(str+2)=e+0x30;
  return str;
}

char* Convert_hex_to_str( IN BYTE byte)
{
  char* str="0x00";
  BYTE h=byte/16;
  BYTE d=byte%16;
  if (h>9)*(str+2)=h+0x37;
    else *(str+2)=h+0x30;
  if (d>9)*(str+3)=d+0x37;
    else *(str+3)=d+0x30;    
  return str;
}

/**********************************************************************************************/